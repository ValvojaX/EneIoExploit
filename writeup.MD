# Ene

## Environment

I used VMWare Workstation for the ability to create snapshots and quickly recover the machine state if something went wrong. I used WinDbg Preview to debug the driver. For running the driver I used Driver Loader from [osronline](https://www.osronline.com/).

## Introduction 

I will only cover how I was able to get arbitrary ZwMapViewOfSection, because it is enough to proof the exploit and also probably the most useful function to exploit. For example, arbitrary ZwMapViewOfSection can be used for local privilege escalation.

## Walkthrough

### Analyzing

The driver is rather small and only contains a couple of functions. I used [Ghidra](https://ghidra-sre.org/) to disassemble the driver. On Ghidra we can see that it found 6 functions excluding memcpy and entry functions.

![](Images/CaptureGhidra1.PNG)

Drivers commonly use a protocol where you specify a control code (IO_CTL code) based on the operation. A program can also include an input buffer and an output buffer for providing input to the driver and to receive output. The next step is to go through the functions and see where the received IO_CTL codes are handled. Since there are only a few functions, we can find the handler function quickly.

![](Images/CaptureGhidra2.PNG)

The driver has left DbgPrint function calls in the source code, which makes reversing it a lot easier. On line 43 we can see a debug print "IOCTL_WINIO_MAPPHYSTOLIN" referring to a IOCTL code that maps physical memory to linear address space. The control code translates to 0x80102040 in hexadecimal. We can also see that there seem to be no checks to prevent anyone from using this control code. On this block there doesn't seem to be too much happening. There is a function call on line 46, so next step is to analyze what happens in there.

![](Images/CaptureGhidra3.PNG)

In here we can immediately see interesting function calls. On line 36 a section is opened with [ZwOpenSection](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwopensection) and the section handle is saved. On line 41 [ObReferenceObjectByHandle](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obreferenceobjectbyhandle) is called to receive a reference to an Object from the section handle. On lines 49 and 51 [HalTranslateBusAddress](https://learn.microsoft.com/en-us/previous-versions/windows/embedded/ms899361(v=msdn.10)) is called, which is used to translate a physical bus address into a physical system address. The driver sets the AddressSpace parameter to 0, which means memory address space. On line 58 the driver calls [ZwMapViewOfSection](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwmapviewofsection) to map the view. If this call returns an NTSTATUS code [STATUS_CONFLICTING_ADDRESSES](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55) (0xC0000018), the function is called again with the Win32Protect parameter changed. Now that we know where the mapping is done, we can start trying to make the driver map a view for us.

### Renaming

Because Ghidra recognized some of the functions that have documentation by Microsoft, we can rename some of the variables based on the documentation to make the pseudocode more readable. We can also rename the functions to IOCTL_Handler and MapPhysToLin.

![](Images/CaptureGhidra4.PNG)

### Interacting with the driver

The next step is to try and make the driver map a view for our own program. On Windows we can pass IOCTL codes with [DeviceIoControl](https://learn.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol). The function takes needs a handle to the driver, which we can get with [CreateFile](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew)

![](Images/Capture1.PNG)

The function will also need the IOCTL code 0x80102040 and a pointer to a variable that will receive the bytes returned by the driver. Input and output buffers are optional, but since we want to see if we can control the parameters of ZwMapViewOfSection to map a view to our own process, we can send the driver a dummy input as well as an empty byte array for possible output.

![](Images/Capture2.PNG)

This example buffer should be easily distinguishable from the rest of the memory. The next step is to launch a virtual machine with kernel debugging enabled and WinDbg attached. Then we need to start the driver, which can be done either by using the software that utilizes the driver or by starting the driver manually. I used OSR Driver Loader to start the driver.

### WinDbg debugging

Before running the program ensure the driver is listed in the loaded module list.
```
lm
```

![](Images/Capture3.PNG)

Now we set breakpoints at both ZwMapViewOfSection calls. The offsets can be seen on Ghidra by clicking on the line where the function call is on. The offset will be showed on bottom right or next to the assembly code.

```
bp ene+16dd
bp ene+1730
```

![](Images/Capture4.PNG)

Now we run our program and see that the first breakpoint got hit at the function call to ZwMapViewOfSection.

![](Images/Capture5.PNG)

We can also inspect the assembly code that is being executed. The assembly code is more reliable here than on a disassembler because the instructions are from the running program instance.

![](Images/Capture6.PNG)

From here we can see which parameter matches which register. ZwMapViewOfSection takes 10 parameters, and they are put to the registers before the function call. Assuming the calling convention is fastcall, parameters are filled from left to right in the order: RCX, RDX, R8, R9. The rest of the parameters are pushed on the stack (RSP). This means the first parameter (SectionHandle) should be in the RCX register. The second parameter (ProcessHandle) should be in the RDX register and so on. From the disassembly on WinDbg we can see where in the stack the last 6 parameters are pushed. For example the fifth parameter (CommitSize) should be at RSP+20 and the sixth parameter (SectionOffset) should be at RSP+20 and so on.

Let's view the common register values
```
r
```

![](Images/Capture7.PNG)

Some registers contain pointers to other addresses. Pointers can be followed by running

```
dd [Address | Register]
```

For example:

![](Images/Capture8.PNG)

After analyzing all the interesting registers we are left with the following information.

![](Images/Capture9.PNG)

Now we have an idea what the input buffer might look like. First 8 bytes will be the CommitSize and the second 8 bytes will be the SectionOffset. At this point the system crashed, because it attempted to map physical memory in these ranges. This means the offsets used in the next part have most likely changed.

We still do not know where the results are stored. Looking at the MAPPHYSTOLIN block in IOCTL_Handler we see two memcpy function calls before and after the MapPhysToLin function call. The _Src parameter is probably a pointer to the input buffer sent to the driver. This can be confirmed by putting a breakpoint on memcpy and viewing register values as we did before. The second memcpy copies the result back to the provided buffer.

![](Images/CaptureGhidra5.PNG)

The next part was a bit trickier, because I did not know what else is in the input buffer other than CommitSize and SectionOffset. I added byte array padding to the input buffer. This way if something gets written to the input buffer, we can inspect the bytes in the padding. Making the padding too large crashed the system, but keeping it below 32 bytes worked.

![](Images/Capture10.PNG)

Now we can try again with a more reasonable buffer, because we know the first two items of the struct. This time we will try to allocate 1024 bytes at the offset 0. After that lets print each byte in the received buffer so we can analyze the output.

![](Images/Capture11.PNG)

We see that our padding got filled. The first row is our CommitSize and the second row is SectionOffset. Third row has the value 0xb0, which looks like the section handle, which was 0xd8 before system crash. The value on the fourth row might be a bit harder to interpret. We know the view must be mapped into userspace, which would mean we should get a userspace memory address in the response. The value on the fifth row looks like a kernel address. We can assume this is the address to the Object reference, because ideally the reference will be dereferenced when it's no longer used and we will need the address for that. These can be confirmed by setting breakpoints and viewing the refreshed values on WinDbg.

![](Images/Capture12.PNG)

Based on our analysis our final input buffer looks like this.

![](Images/Capture13.PNG)

Our refactored function looks like this

![](Images/Capture14.PNG)

Let's try to map a view of 1024 * 1024 bytes.

![](Images/Capture15.PNG)

We can confirm with [Process Hacker 2](https://processhacker.sourceforge.io/) that memory chunk of roughly 16 megabytes was mapped to the program.

![](Images/Capture16.PNG)

We can also dump the allocated memory from BaseAddress to CommitSize into a .txt file. By doing this we can see information about the system, which confirms that the mapped memory is actually from system memory and outside the process' own address space.

![](Images/Capture17.PNG)

## Local Privilige Escalation PoC

Now that we actually have an arbitrary ZwMapViewOfSection, let's prove it by using it to escalate privileges on a local machine. For this PoC I used the same method that was used in a [PoC](https://fuzzysecurity.com/tutorials/expDev/23.html) for CVE-2017-14398. 

### Description

To gain SYSTEM priviliges, we are going to overwrite a powershell process' token with a SYSTEM token. We steal the SYSTEM token from lsass.exe.

### Offsets

This PoC relies on offsets that depend on Windows version. The offsets will most likely have to be updated for different Windows versions, which can be done with WinDbg or by finding the offsets online. From EPROCESS structure, which is used to represent process data in Windows, we need the fields "UniqueProcessId", "ImageFileName" and "Token". The offsets can be retreived with WinDbg like so.

```
dt nt!_EPROCESS UniqueProcessId ImageFileName Token
```

![](Images/Capture18.PNG)

### Memory pages

The memory buffer allocated with ZwMapViewOfMemory is physical memory. This makes it harder to handle addresses, because proper usage requires translating linear memory into physical memory. To keep the PoC relatively small, I have not implemented address translation function. This could be done with a library like [UMPMLib](https://github.com/waryas/UMPMLib).

Pool headers are used, because they have a static value (depends on Windows version) and they are located in the same page as the eprocess. The location of the eprocess can then be calculated from the position of the pool header. Calculating the distance, or "pool header", can be done on WinDbg like so.

Get process kernel address

```
!process 0 0 [process name]
```

Find the pool that the process kernel address is located in

```
!pool [memory address]
```

Now by subtracting the pool address from the process address you get the pool header size.

![](Images/Capture19.PNG)

To find the value of pool header, we can use one of the pool addresses and dissect it into a POOL_HEADER structure with WinDbg. The static value is located in the PoolTag field.

```
dt nt!_POOL_HEADER [address]
```

![](Images/Capture20.PNG)

### Structs

To avoid using more offsets, I defined the structures for pool headers and tokens. These can be dissected with WinDbg like so.

```
dt nt!_POOL_HEADER
dt nt!_EX_FAST_REF
```

![](Images/Capture21.PNG)

We're only interested in the PoolTag field for POOL_HEADER and Value for EX_FAST_REF, so some fields have been left out.

![](Images/Capture22.PNG)

### PoC

Now let's put everything together. We start by mapping some memory to user space.

![](Images/Capture23.PNG)

After this we initialize the offset values and variables to store the eprocess locations into.

![](Images/Capture24.PNG)

Then we start iterating the allocated physical memory. We read values into a pool header structure we defined earlier and check if the PoolTag field value matches the static value. If it does, we have found a potential pool header structure. Then we calculate the EPROCESS position based on the pool header sizes we calculated earlier. In this case, we had the header sizes 0x70 and 0x80, so we will check both. With the calculated EPROCESS address we calculate the position of ImageFileName field and read it to confirm that 1. We have a valid EPROCESS structure and 2. We are in the correct process (lsass or powershell). When we have found both EPROCESS locations, we calculate the Token location for both processes. Then we overwrite Token.Value of lsass.exe into Token.Value field of powershell.exe. After this we exit the loop and should have system privileges.

![](Images/Capture25.PNG)

Iterating the allocated memory takes a while especially, if the pool headers are located in the end of the buffer. If both pool headers are not found, the CommitSize for ZwMapViewOfSection can be increased.

![](Images/Capture26.PNG)

## Platforms tested

- Windows 10 x64 Build 19044 (21H2)

## Credits

Exploit development inspired by https://fuzzysecurity.com/tutorials/expDev/23.html with a similar vulnerability.