# Ene

## Environment

I used VMWare Workstation for the ability to create snapshots and quickly recover the machine state if something went wrong. I used WinDbg Preview to debug the driver. For running the driver I used Driver Loader from [osronline](https://www.osronline.com/).

## Introduction 

I will only cover how I was able to get arbitrary ZwMapViewOfSection, because it is enough to proof the exploit and also probably the most useful function to exploit. 

## Walkthrough

The driver is rather small; loading it with Ghidra the IOCTL handler function can be found fairly easily. Debug prints on the pseudocode makes it easy to determine what each control code does. 

![](Images/GhidraCapture1.PNG)

We're interested in the IOCTL_WINIO_MAPPHYSTOLIN control code 0x80102040. As seen in the pseudocode, there are no checks to prevent anyone from using this control code to map physical memory to linear address space. ZwMapViewOfSection is called from FUN_00011528, which is called on the line 46. At this point, I'll rename the functions to IOCTL_Handler and MapPhysToLin for clearity. I will also rename parameter names for the known functions that have documentation available by Microsoft. The used documentation pages will be listed below. 

![](Images/GhidraCapture2.PNG)

In MapPhysToLin we can see a section is first opened. Then we receive an object by the section handle. Then we use HalTranslateBusAddress to translate a physical bus address to a physical system address. The AddressSpace parameter is set to 0, which means memory address space. After that we use ZwMapViewOfSection to map a view from SectionOffset to SectionOffset + CommitSize. Let's try to call this function using the driver.

![](Images/Capture1.PNG)

This example buffer should be easily distinguishable from the rest of the memory. Let's ensure our driver is loaded and WinDbg has it's address. If not, attach WinDbg and start ene.sys with OSR Driver Loader.

![](Images/Capture2.PNG)

After this let's set breakpoints on MapPhysToLin call and both ZwMapViewOfSection calls. Offsets can be checked from Ghidra.

![](Images/Capture3.PNG)

Now we run the program with the test buffer and the first breakpoint at MapPhysToLin should get hit. We can then see the values at each register.

![](Images/Capture4.PNG)

We can also see the assembly executed before the breakpoint.

![](Images/Capture5.PNG)

From here we can see which parameter matches which register. MapPhysToLin takes 5 parameters, and they are put to the registers before the function call. Assuming the calling convention is fastcall, parameters are filled from left to right in the order: RCX, RDX, R8, R9. The fifth parameter in this case is stored in R11.

Let's continue execution. We should now hit the first ZwMapViewOfSection.

![](Images/Capture7.PNG)

Now let's repeat the steps from before. This time it's a bit more tricky, since ZwMapViewOfSection takes 10 parameters. First parameters go to registers RCX, RDX, R8 and R9 similarly to before, and the rest get pushed on the stack (RSP). This can be seen on WinDbg like before.

![](Images/Capture8.PNG)

Now we have an idea what the input buffer might look like. First 8 bytes will be the CommitSize and the second 8 bytes will be the SectionOffset. At this point the system crashed, because it attempted to map physical memory in these ranges. This means the following offsets might be off from before.

We still do not know where the results are stored, but it's safe to assume it will have to be passed back to the usermode program that called DeviceIoControl. We know the third parameter of MapPhysToLin is set to the received base address from ZwMapViewOfAddress call.

![](Images/GhidraCapture3.PNG)

Reversing the rest of the buffer structure was a harder task, because the driver uses memcpy to copy the response buffer. At first I assumed the output would go into a seperate buffer, but that was not the case. I used a byte array as the output buffer, but nothing was written to it. Then I added byte array padding to the input buffer. Making the padding too large crashed the system, but keeping it below 32 bytes worked.

![](Images/Capture9.PNG)

Let's try again with a buffer that makes more sense. This time we will try to allocate 1024 bytes at the offset 0. After that let's print each byte in the received buffer.

![](Images/Capture10.PNG)

We see that our padding got filled. The first row is our CommitSize and the second row is SectionOffset. Third row has the value 0xb0, which we passed to ZwMapViewOfSection as SectionHandle. This means the third byte of the input buffer will be the handle of the section. The value on the fourth row might be a bit harder to interpret. We know the view must be mapped into userspace, which would mean we get a userspace memory address. The fourth row is the BaseAddress which was updated in the end of MapPhysToLin. I did not realize there was a fifth address until I started looking at the input buffer struct for ZwUnmapViewOfSection, which takes a kernel address to an Object as a parameter. The fifth address is the address of the Object received from ObReferenceObjectByHandle.

![](Images/Capture11.PNG)

Our final buffer looks like this

![](Images/Capture12.PNG)

Our refactored function looks like this

![](Images/Capture13.PNG)

Let's try to map a view of 1024 * 1024 bytes.

![](Images/Capture14.PNG)

We can confirm that memory chunk of roughly 16 megabytes was mapped to the program on Process Hacker 2.

![](Images/Capture15.PNG)

If we want to be extra sure, we can dump the allocated memory from BaseAddress to CommitSize into a .txt file.

![](Images/Capture16.PNG)


## Used Documentation

[ZwOpenSection](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwopensection)

[ObReferenceObjectByHandle](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obreferenceobjectbyhandle)

[HalTranslateBusAddress](https://learn.microsoft.com/en-us/previous-versions/windows/embedded/ms899361(v=msdn.10))

[ZwMapViewOfSection](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwmapviewofsection)